import { test, expect, describe } from "vitest";

import { BufferTokenizer } from "../../../strtok3/BufferTokenizer";
import { u8 } from "../../primitive/integer";
import { readUnitFromTokenizer } from "../../utility/read-unit";
import { metadataObject } from "../metadata";

import type { ITag } from "../../../type";
import type { GUID } from "../guid";

describe("unit size: content description object", () => {
  test("content description object", () => {
    const [size] = metadataObject(50);

    expect(size).toBe(50);
  });
});

type Case = [description: string, source: number[], expected: ITag[]];
const cases: Case[] = [
  [
    "parse content description object",
    [
      // content descriptor count
      0x06, 0x00,
      // string content
      0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x54, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6c,
      0x00, 0x65, 0x00, 0x54, 0x00, 0x49, 0x00, 0x54, 0x00, 0x4c, 0x00, 0x45, 0x00,
      // buffer content
      0x00, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x42, 0x00, 0x75, 0x00, 0x66, 0x00, 0x66,
      0x00, 0x65, 0x00, 0x72, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      // boolean content
      0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x42, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x6c,
      0x00, 0x01, 0x00, 0x00, 0x00,
      // 32bit int content
      0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x57, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x64,
      0x00, 0x12, 0x00, 0x23, 0x00,
      // WM/Picture content
      0x00, 0x00, 0x01, 0x00, 0x14, 0x00, 0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 0x57, 0x00, 0x4d, 0x00, 0x2f, 0x00, 0x50,
      0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x75, 0x00, 0x72, 0x00, 0x65, 0x00, 0x01, 0x80, 0x00, 0x10, 0x00, 0x6a,
      0x00, 0x70, 0x00, 0x65, 0x00, 0x67, 0x00, 0x00, 0x00, 0x69, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00,
      0x00, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa,
      // GUID content
      0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x47, 0x00, 0x55, 0x00, 0x49, 0x00, 0x44,
      0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0x11, 0x22, 0x44, 0x55, 0x0f, 0x1e, 0x2d, 0x3c, 0x4b, 0x5a, 0x69, 0x78,
    ],
    [
      { id: "Title", value: "TITLE" },
      { id: "Buffer", value: new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a]) },
      { id: "Bool", value: true },
      { id: "Word", value: 0x00_23_00_12 },
      {
        id: "WM/Picture",
        value: {
          type: "32x32 pixels 'file icon' (PNG only)",
          format: "jpeg",
          description: "image",
          size: 0x00_10_00_80,
          data: new Uint8Array([0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa]),
        },
      },
      { id: "GUID", value: "DDCCBBAA-2211-5544-0F1E-2D3C4B5A6978" as GUID },
    ],
  ],
];

describe("unit: content description object", () => {
  test.each(cases)("%s", async (_, bytes, expected) => {
    const buffer = new Uint8Array(bytes);
    const tokenizer = new BufferTokenizer(buffer);
    const result = readUnitFromTokenizer(tokenizer, metadataObject(buffer.length));

    await expect(result).resolves.toEqual(expected);

    // all bytes are read
    await expect(readUnitFromTokenizer(tokenizer, u8)).rejects.toThrow();
  });
});
